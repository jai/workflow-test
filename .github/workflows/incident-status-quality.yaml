---
name: Incident Status Quality

on:
  schedule:
    # Top of every hour (adjust as needed once validated)
    - cron: 0 * * * *
  # yamllint disable-line rule:empty-values
  workflow_dispatch:

permissions:
  contents: read
  issues: read

jobs:
  status-quality:
    if: >
      github.event_name == 'schedule' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       github.event.issue.pull_request &&
       contains(github.event.comment.body, '/run incident-status-quality'))
    runs-on: ubuntu-latest
    env:
      WINDOW_HOURS: ${{ vars.INCIDENT_STATUS_WINDOW_HOURS || '24' }}
      MAX_INCIDENTS: ${{ vars.INCIDENT_STATUS_MAX_INCIDENTS || '' }}
      INCIDENT_DATA_PATH: incident-status-data.json
      INCIDENT_PROMPT_PATH: incident-status-prompt.json
      DECISIONS_PATH: incident-status-decisions.json

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('scripts/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Cache incident data
        uses: actions/cache@v4
        with:
          path: scripts/.cache
          key: status-quality-cache-${{ github.run_id }}
          restore-keys: |
            status-quality-cache-

      - name: Install dependencies
        run: pip install -r scripts/requirements.txt

      - name: Run incident status collector
        env:
          GRAFANA_TOKEN: ${{ secrets.GRAFANA_API_KEY }}
          GRAFANA_URL: https://finnapp.grafana.net
        run: |
          set -euo pipefail
          ARGS=(
            --window-hours "$WINDOW_HOURS"
            --output-json "$INCIDENT_DATA_PATH"
            --prompt-output "$INCIDENT_PROMPT_PATH"
            --cache-dir "scripts/.cache/incidents"
          )
          if [[ -n "${MAX_INCIDENTS}" ]]; then
            ARGS+=(--max-incidents "$MAX_INCIDENTS")
          fi
          python scripts/incident_status_quality.py "${ARGS[@]}"

      - name: Inspect dataset
        id: dataset
        run: |
          python <<'PY'
          import json, os
          path = os.environ["INCIDENT_DATA_PATH"]
          data = json.load(open(path))
          count = len(data.get("incidents", []))
          print(f"Incidents collected: {count}")
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
              fh.write(f"incident_count={count}\n")
          PY

      - name: Prepare prompt payload
        id: prompt
        if: steps.dataset.outputs.incident_count != '0'
        run: |
          python <<'PY'
          import os
          from pathlib import Path

          payload = Path(os.environ["INCIDENT_PROMPT_PATH"]).read_text()
          gh_output = Path(os.environ["GITHUB_OUTPUT"])

          with gh_output.open("a", encoding="utf-8") as fh:
              fh.write("payload<<__PROMPT_JSON__\n")
              fh.write(payload)
              if not payload.endswith("\n"):
                  fh.write("\n")
              fh.write("__PROMPT_JSON__\n")
          PY

      - name: Evaluate status updates with Claude
        id: claude
        if: steps.dataset.outputs.incident_count != '0'
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            You are auditing Grafana IRM incident status updates.

            Evaluate whether each incident's most recent human-authored status update
            (provided as JSON below) satisfies two requirements:
            1. Summarizes what has happened so far in the incident.
            2. Outlines clear next steps or owner follow-up actions.

            Context:
            - Consider the look-back window (last ${{ env.WINDOW_HOURS }}h); timestamps are
              included for context only.
            - Treat "status_update_missing": true as an automatic failure.
            - If the text is truncated, base your decision on the truncated excerpt and
              mention the limitation in notes when uncertain.

            INCIDENTS JSON:
            <<<INCIDENTS_JSON>>>
            ${{ steps.prompt.outputs.payload }}
            <<<END_INCIDENTS_JSON>>>

            Output EXACTLY one machine-readable line using this schema:
            STATUS_DECISIONS::[
              {
                "incident_id": "string",
                "summaryAdequate": true|false,
                "nextStepsAdequate": true|false,
                "overallStatus": "pass"|"fail",
                "notes": ["string"]
              },
              ...
            ]

            Rules:
            - Use lowercase true/false for booleans.
            - Set overallStatus to "fail" whenever either summaryAdequate or nextStepsAdequate is false.
            - Include at least one short note when overallStatus is "fail".
            - Do not include extra commentary before or after the STATUS_DECISIONS line.
          claude_args: |
            --model claude-sonnet-4-5-20250929
            --max-turns 12
            --allowedTools Read
            --disallowedTools Bash,Grep,TodoWrite,Edit,Write,WebSearch,WebFetch,NotebookEdit

      - name: Parse Claude decisions
        id: decisions
        if: steps.dataset.outputs.incident_count != '0'
        env:
          EXECUTION_FILE: ${{ steps.claude.outputs.execution_file }}
        run: |
          python <<'PY'
          import json
          import os
          import re
          from pathlib import Path

          exec_file = Path(os.environ["EXECUTION_FILE"])
          marker = re.compile(r"STATUS_DECISIONS::(\[.*\])", re.DOTALL)
          turns = json.loads(exec_file.read_text())

          decisions = None
          total_input = 0
          total_output = 0
          duration_ms = 0
          cost = 0.0

          for turn in turns:
              if turn.get("type") == "result":
                  duration_ms = max(duration_ms, turn.get("duration_ms") or 0)
                  cost = max(cost, turn.get("total_cost_usd") or 0.0)
                  continue
              if turn.get("type") != "assistant":
                  continue
              message = turn.get("message") or {}
              usage = message.get("usage") or {}
              total_input += (
                  (usage.get("input_tokens") or 0)
                  + (usage.get("cache_creation_input_tokens") or 0)
                  + (usage.get("cache_read_input_tokens") or 0)
              )
              total_output += usage.get("output_tokens") or 0
              if decisions is not None:
                  continue
              for content in message.get("content", []):
                  text = content.get("text")
                  if not text:
                      continue
                  match = marker.search(text)
                  if match:
                      decisions = json.loads(match.group(1))
                      break
          if decisions is None:
              raise SystemExit("Claude output missing STATUS_DECISIONS marker.")

          fail_count = sum(1 for item in decisions if item.get("overallStatus") == "fail")
          pass_count = len(decisions) - fail_count

          Path(os.environ["DECISIONS_PATH"]).write_text(json.dumps(decisions, indent=2))

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
              fh.write(f"fail_count={fail_count}\n")
              fh.write(f"pass_count={pass_count}\n")
              fh.write(f"decision_file={os.environ['DECISIONS_PATH']}\n")
              fh.write(f"token_input={total_input}\n")
              fh.write(f"token_output={total_output}\n")
              fh.write(f"duration_ms={duration_ms}\n")
              fh.write(f"total_cost_usd={cost}\n")
          PY

      - name: Send Google Chat notification
        if: steps.dataset.outputs.incident_count != '0'
        env:
          WEBHOOK_URL: ${{ secrets.GOOGLE_CHAT_INCIDENT_STATUS_QUALITY_WEBHOOK_URL }}
        run: |
          python <<'PY'
          import html
          import json
          import os
          from pathlib import Path

          webhook = os.environ.get("WEBHOOK_URL")
          if not webhook:
              print("Google Chat webhook not configured; skipping notification.")
              raise SystemExit(0)

          import requests

          def fmt_text(value: str) -> str:
              if not value:
                  return "_No status text provided_"
              return html.escape(value).replace("\n", "<br>")

          data = json.loads(Path(os.environ["INCIDENT_DATA_PATH"]).read_text())
          decisions = json.loads(Path(os.environ["DECISIONS_PATH"]).read_text())
          incident_map = {item["incident_id"]: item for item in data.get("incidents", [])}

          pass_count = sum(1 for d in decisions if d.get("overallStatus") == "pass")
          window_hours = os.environ["WINDOW_HOURS"]

          missing_updates = []
          update_failures = []
          for decision in decisions:
              inc = incident_map.get(decision["incident_id"])
              if not inc:
                  continue
              status_info = inc.get("status_update") or {}
              if status_info.get("missing"):
                  missing_updates.append(inc)
                  continue
              if decision.get("overallStatus") == "fail":
                  update_failures.append((inc, decision))

          def build_failure_section(inc, decision):
              status = inc.get("status_update") or {}
              summary_flag = "✅" if decision.get("summaryAdequate") else "❌"
              next_flag = "✅" if decision.get("nextStepsAdequate") else "❌"
              author = status.get("author_display") or "Unknown responder"
              ts = status.get("timestamp") or "unknown time"
              url = inc.get("overview_url")
              header = [
                  f"<b>{html.escape(inc.get('title', inc['incident_id']))}</b> (Severity: {html.escape(inc.get('severity', 'unknown'))})",
                  f"{summary_flag} Summary | {next_flag} Next steps",
              ]
              if url:
                  header.append(f"<a href=\"{url}\">Open incident</a>")

              status_block = (
                  f"<i>Latest update ({html.escape(ts)}) by {html.escape(author)}:</i><br>"
                  f"{fmt_text(status.get('text'))}"
              )
              notes = decision.get("notes") or []
              notes_block = ""
              if notes:
                  escaped_notes = "<br>• ".join(html.escape(n) for n in notes)
                  notes_block = f"Notes:<br>• {escaped_notes}"

              text = "<br>".join(part for part in [*header, status_block, notes_block] if part)
              return {"widgets": [{"textParagraph": {"text": text}}]}

          def build_missing_card():
              header = {
                  "title": f"Missing incident updates — last {window_hours}h",
                  "subtitle": "Claude incident status audit",
              }
              lines = []
              for inc in missing_updates:
                  url = inc.get("overview_url")
                  title = html.escape(inc.get("title", inc["incident_id"]))
                  severity = html.escape(inc.get("severity", "unknown"))
                  line = f"• {title} (Severity: {severity})"
                  if url:
                      line = f"{line} — <a href=\"{url}\">Open</a>"
                  lines.append(line)
              body = "<br>".join(lines) if lines else "All incidents have recent updates."
              return {
                  "header": header,
                  "sections": [
                      {
                          "widgets": [
                              {"textParagraph": {"text": f"{len(missing_updates)} incidents missing updates."}}
                          ]
                      },
                      {"widgets": [{"textParagraph": {"text": body}}]},
                  ],
              }

          summary_lines = [
              f"Incidents evaluated: {len(decisions)}",
              f"Passing updates: {pass_count}",
              f"Action needed: {len(update_failures)}",
          ]
          main_sections = [
              {"widgets": [{"textParagraph": {"text": "<br>".join(summary_lines)}}]}
          ]
          if update_failures:
              for inc, decision in update_failures:
                  main_sections.append(build_failure_section(inc, decision))
          else:
              main_sections.append(
                  {"widgets": [{"textParagraph": {"text": "✅ All incidents with status updates meet the requirements."}}]}
              )

          cards = [
              {
                  "header": {
                      "title": f"Incident status quality check — last {window_hours}h",
                      "subtitle": "Claude incident status audit",
                  },
                  "sections": main_sections,
              }
          ]
          if missing_updates:
              cards.append(build_missing_card())

          payload = {"cards": cards}
          resp = requests.post(webhook, json=payload, timeout=20)
          if resp.status_code >= 300:
              raise SystemExit(f"Chat webhook failed: {resp.status_code} {resp.text}")
          print("Posted results to Google Chat.")
          PY

      - name: Collect artifacts
        if: always()
        env:
          EXECUTION_FILE: ${{ steps.claude.outputs.execution_file }}
        run: |
          mkdir -p artifact-bundle
          cp "$INCIDENT_DATA_PATH" artifact-bundle/ 2>/dev/null || true
          cp "$INCIDENT_PROMPT_PATH" artifact-bundle/ 2>/dev/null || true
          cp "$DECISIONS_PATH" artifact-bundle/ 2>/dev/null || true
          if [[ -n "${EXECUTION_FILE}" && -f "${EXECUTION_FILE}" ]]; then
            cp "${EXECUTION_FILE}" artifact-bundle/claude-execution.json
          fi

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: incident-status-quality-${{ github.run_id }}
          path: artifact-bundle
          retention-days: 14
